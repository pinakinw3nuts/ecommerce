import { FastifyRequest, FastifyReply } from 'fastify';
import { z } from 'zod';
import { ContentService } from '../services/content.service';
import { ContentBlockType } from '../entities/ContentBlock';
import { logger } from '../utils/logger';
import { validateRequest } from '../middleware/validateRequest';

// Define request types
interface CreateContentRequest extends FastifyRequest {
  body: {
    title: string;
    slug?: string;
    type: ContentBlockType;
    content: Record<string, any>;
    isPublished?: boolean;
    publishAt?: string;
    expiresAt?: string | null;
    metaTitle?: string;
    metaDescription?: string;
    metaKeywords?: string;
    ogImage?: string;
    metadata?: Record<string, any>;
    sortOrder?: number;
    parentId?: string;
    locale?: string;
    masterContentBlockId?: string;
  }
}

interface UpdateContentRequest extends FastifyRequest {
  params: {
    id: string;
  };
  body: {
    title?: string;
    slug?: string;
    type?: ContentBlockType;
    content?: Record<string, any>;
    isPublished?: boolean;
    publishAt?: string | null;
    expiresAt?: string | null;
    metaTitle?: string | null;
    metaDescription?: string | null;
    metaKeywords?: string | null;
    ogImage?: string | null;
    metadata?: Record<string, any>;
    sortOrder?: number;
    parentId?: string | null;
    locale?: string;
    masterContentBlockId?: string | null;
    changeDescription?: string;
  }
}

interface GetContentBySlugRequest extends FastifyRequest {
  params: {
    slug: string;
  };
  query: {
    locale?: string;
    type?: ContentBlockType;
    published?: 'true' | 'false';
  }
}

interface GetContentByIdRequest extends FastifyRequest {
  params: {
    id: string;
  };
}

interface TogglePublishRequest extends FastifyRequest {
  params: {
    id: string;
  };
  body: {
    isPublished: boolean;
    publishAt?: string;
    expiresAt?: string | null;
  }
}

/**
 * Controller for content management endpoints
 */
export class ContentController {
  private contentService: ContentService;
  private contextLogger = logger.child({ context: 'ContentController' });

  constructor() {
    this.contentService = new ContentService();
  }

  /**
   * Create a new content block
   * @route POST /content
   */
  createContent = [
    validateRequest(
      z.object({
        body: z.object({
          title: z.string().min(1).max(200),
          slug: z.string().min(1).max(200).optional(),
          type: z.nativeEnum(ContentBlockType),
          content: z.record(z.any()).default({}),
          isPublished: z.boolean().optional(),
          publishAt: z.string().datetime().optional(),
          expiresAt: z.string().datetime().optional().nullable(),
          metaTitle: z.string().max(100).optional(),
          metaDescription: z.string().max(250).optional(),
          metaKeywords: z.string().optional(),
          ogImage: z.string().optional(),
          metadata: z.record(z.any()).optional(),
          sortOrder: z.number().int().optional(),
          parentId: z.string().uuid().optional(),
          locale: z.string().min(2).max(10).optional(),
          masterContentBlockId: z.string().uuid().optional()
        })
      })
    ),
    async (req: CreateContentRequest, reply: FastifyReply) => {
      try {
        const userId = req.headers['x-user-id'] as string;
        
        // Transform request body to match CreateContentBlockInput
        const contentData = {
          ...req.body,
          // Convert string dates to Date objects if present
          publishAt: req.body.publishAt ? new Date(req.body.publishAt) : undefined,
          expiresAt: req.body.expiresAt ? new Date(req.body.expiresAt) : undefined,
          // Ensure slug is present (will be generated by service if undefined)
          slug: req.body.slug || ''
        };
        
        const contentBlock = await this.contentService.createContentBlock(contentData, userId);
        
        this.contextLogger.info('Content block created', { 
          id: contentBlock.id, 
          title: contentBlock.title 
        });
        
        return reply.status(201).send({
          success: true,
          data: contentBlock
        });
      } catch (error) {
        this.contextLogger.error('Failed to create content block', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          body: req.body
        });
        
        return reply.status(500).send({
          success: false,
          message: 'Failed to create content block',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }
  ];

  /**
   * Get content block by ID
   * @route GET /content/:id
   */
  getContentById = [
    validateRequest(
      z.object({
        params: z.object({
          id: z.string().uuid()
        })
      })
    ),
    async (req: GetContentByIdRequest, reply: FastifyReply) => {
      try {
        const { id } = req.params;
        const contentBlock = await this.contentService.getContentBlockById(id);
        
        if (!contentBlock) {
          return reply.status(404).send({
            success: false,
            message: `Content block with ID ${id} not found`,
            error: 'NOT_FOUND'
          });
        }
        
        return reply.status(200).send({
          success: true,
          data: contentBlock
        });
      } catch (error) {
        this.contextLogger.error('Failed to get content block', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          id: req.params.id
        });
        
        return reply.status(500).send({
          success: false,
          message: 'Failed to get content block',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }
  ];

  /**
   * Update an existing content block
   * @route PUT /content/:id
   */
  updateContent = [
    validateRequest(
      z.object({
        params: z.object({
          id: z.string().uuid()
        }),
        body: z.object({
          title: z.string().min(1).max(200).optional(),
          slug: z.string().min(1).max(200).optional(),
          type: z.nativeEnum(ContentBlockType).optional(),
          content: z.record(z.any()).optional(),
          isPublished: z.boolean().optional(),
          publishAt: z.string().datetime().optional().nullable(),
          expiresAt: z.string().datetime().optional().nullable(),
          metaTitle: z.string().max(100).optional().nullable(),
          metaDescription: z.string().max(250).optional().nullable(),
          metaKeywords: z.string().optional().nullable(),
          ogImage: z.string().optional().nullable(),
          metadata: z.record(z.any()).optional(),
          sortOrder: z.number().int().optional(),
          parentId: z.string().uuid().optional().nullable(),
          locale: z.string().min(2).max(10).optional(),
          masterContentBlockId: z.string().uuid().optional().nullable(),
          changeDescription: z.string().optional()
        })
      })
    ),
    async (req: UpdateContentRequest, reply: FastifyReply) => {
      try {
        const { id } = req.params;
        const userId = req.headers['x-user-id'] as string;
        const { changeDescription, ...updateDataRaw } = req.body;
        
        // Transform request body to match UpdateContentBlockInput
        const updateData = {
          ...updateDataRaw,
          // Convert string dates to Date objects or null
          publishAt: updateDataRaw.publishAt === null 
            ? null 
            : updateDataRaw.publishAt 
              ? new Date(updateDataRaw.publishAt) 
              : undefined,
          expiresAt: updateDataRaw.expiresAt === null 
            ? null 
            : updateDataRaw.expiresAt 
              ? new Date(updateDataRaw.expiresAt) 
              : undefined
        };
        
        const contentBlock = await this.contentService.updateContentBlock(
          id, 
          updateData, 
          userId,
          changeDescription
        );
        
        this.contextLogger.info('Content block updated', { 
          id: contentBlock.id, 
          title: contentBlock.title 
        });
        
        return reply.status(200).send({
          success: true,
          data: contentBlock
        });
      } catch (error) {
        this.contextLogger.error('Failed to update content block', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          id: req.params.id,
          body: req.body
        });
        
        if (error instanceof Error && error.message.includes('not found')) {
          return reply.status(404).send({
            success: false,
            message: `Content block with ID ${req.params.id} not found`,
            error: 'NOT_FOUND'
          });
        }
        
        return reply.status(500).send({
          success: false,
          message: 'Failed to update content block',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }
  ];

  /**
   * Get content block by slug
   * @route GET /content/:slug
   */
  getContentBySlug = [
    validateRequest(
      z.object({
        params: z.object({
          slug: z.string()
        }),
        query: z.object({
          locale: z.string().optional(),
          type: z.nativeEnum(ContentBlockType).optional(),
          published: z.enum(['true', 'false']).optional()
        })
      })
    ),
    async (req: GetContentBySlugRequest, reply: FastifyReply) => {
      try {
        const { slug } = req.params;
        const { locale, type, published } = req.query;
        
        let contentBlock;
        
        if (published === 'true') {
          // Get only published content
          contentBlock = type 
            ? await this.contentService.getPublishedContentBlockBySlugAndType(
                slug, 
                type, 
                locale
              )
            : await this.contentService.getPublishedContentBlockBySlug(
                slug, 
                locale
              );
        } else {
          // Get content regardless of publication status
          contentBlock = type 
            ? await this.contentService.getContentBlockBySlugAndType(
                slug, 
                type, 
                locale
              )
            : await this.contentService.getContentBlockBySlug(
                slug, 
                locale
              );
        }
        
        if (!contentBlock) {
          return reply.status(404).send({
            success: false,
            message: `Content block with slug "${slug}" not found`,
            error: 'NOT_FOUND'
          });
        }
        
        return reply.status(200).send({
          success: true,
          data: contentBlock
        });
      } catch (error) {
        this.contextLogger.error('Failed to get content block by slug', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          slug: req.params.slug,
          query: req.query
        });
        
        return reply.status(500).send({
          success: false,
          message: 'Failed to get content block',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }
  ];

  /**
   * Delete a content block
   * @route DELETE /content/:id
   */
  deleteContent = [
    validateRequest(
      z.object({
        params: z.object({
          id: z.string().uuid()
        })
      })
    ),
    async (req: GetContentByIdRequest, reply: FastifyReply) => {
      try {
        const { id } = req.params;
        
        // Check if the content block exists first
        const contentBlock = await this.contentService.getContentBlockById(id);
        
        if (!contentBlock) {
          return reply.status(404).send({
            success: false,
            message: `Content block with ID ${id} not found`,
            error: 'NOT_FOUND'
          });
        }
        
        // Delete the content block
        await this.contentService.deleteContentBlock(id);
        
        this.contextLogger.info('Content block deleted', { id });
        
        return reply.status(200).send({
          success: true,
          message: 'Content block deleted successfully'
        });
      } catch (error) {
        this.contextLogger.error('Failed to delete content block', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          id: req.params.id
        });
        
        return reply.status(500).send({
          success: false,
          message: 'Failed to delete content block',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }
  ];

  /**
   * Toggle publication status of a content block
   * @route PUT /content/:id/publish
   */
  togglePublish = [
    validateRequest(
      z.object({
        params: z.object({
          id: z.string().uuid()
        }),
        body: z.object({
          isPublished: z.boolean(),
          publishAt: z.string().datetime().optional(),
          expiresAt: z.string().datetime().optional().nullable()
        })
      })
    ),
    async (req: TogglePublishRequest, reply: FastifyReply) => {
      try {
        const { id } = req.params;
        const { isPublished, publishAt, expiresAt } = req.body;
        const userId = req.headers['x-user-id'] as string;
        
        // Check if the content block exists
        const contentBlock = await this.contentService.getContentBlockById(id);
        
        if (!contentBlock) {
          return reply.status(404).send({
            success: false,
            message: `Content block with ID ${id} not found`,
            error: 'NOT_FOUND'
          });
        }
        
        let updatedContentBlock;
        
        // If we're scheduling publication
        if (publishAt) {
          updatedContentBlock = await this.contentService.schedulePublication(
            id,
            new Date(publishAt),
            expiresAt ? new Date(expiresAt) : null,
            userId
          );
        } else {
          // Just toggle the publication status
          updatedContentBlock = await this.contentService.updatePublicationStatus(
            id,
            isPublished,
            userId
          );
        }
        
        this.contextLogger.info(`Content block ${isPublished ? 'published' : 'unpublished'}`, { 
          id, 
          title: updatedContentBlock.title 
        });
        
        return reply.status(200).send({
          success: true,
          data: updatedContentBlock,
          message: `Content block ${isPublished ? 'published' : 'unpublished'} successfully`
        });
      } catch (error) {
        this.contextLogger.error('Failed to toggle publication status', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          id: req.params.id,
          body: req.body
        });
        
        return reply.status(500).send({
          success: false,
          message: 'Failed to toggle publication status',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }
  ];
} 